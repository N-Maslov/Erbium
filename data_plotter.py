'''
### DATA PLOTTER ###
Contains functions that read the output data files, and are used for visualisation.
'''
import numpy as np
import matplotlib.pyplot as plt
import setup

def plot_1d(mat:np.ndarray,settings:np.ndarray,slice_index:int)->None:
    '''Generates 10 plots showing how all parameters (indexed as in the label_key below)
    vary across one constant-aspect ratio slice of the plot.
    Inputs:
    - mat: output matrix in the format generated in gen_data_2d (data_generator.py)
    - settings: configuration file as generated by gen_data_2d
    - slice_index: index corresponding to aspect ratio value to use'''

    fig, axs = plt.subplots(2,5)

    # read conditions under which data was generated from file
    f,N,e_min,e_max,e_num,a_min,a_max,a_num = settings
    e_num = int(e_num); a_num = int(a_num); N = int(N)

    e_vals = np.linspace(e_min,e_max,e_num,endpoint=True)
    a_ratio = np.linspace(a_min,a_max,a_num,endpoint=True)[slice_index]

    # select only the relevant slice from the results matrix
    to_plot = mat[:,slice_index,:]

    # plot each parameter on its own axes
    for ax_index,ax in enumerate(np.reshape(axs,(-1))):
        ax.plot(e_vals,to_plot[ax_index,:],'.')
        ax.set_ylabel(label_key[ax_index])
        ax.set_xlabel('e_dd')

    fig.suptitle(f'Parameter minima as a function of e_dd (f = {f} Hz, {N} atoms, aspect ratio = {a_ratio:.3f})')
    plt.show()

def plot_2d(mat:np.ndarray,settings:np.ndarray,mode:int,energies=False,nticksx=11,nticksy=11)->None:
    '''Plots a 2-dimensional heatmap showing the variation of a chosen parameter (or contribution
    to the energy) across different values of e_dd and aspect ratio.
    Inputs:
    - mat: output matrix in the format generated in gen_data_2d (data_generator.py).
        by default, this will be outMat or outEnergies.
    - settings: configuration file as generated by gen_data_2d
    - mode: index selects which parameter or energy contribution to plot. 
        corresponding values are listed in label_key and energy_labels below.
    - energies: if True, will plot the value of a particular term in the Hamiltonian
        (also indexed by mode, selected from energy_labels below)
    - nticksx, nticksy: the number of ticks to show along the x and y axes'''

    # read conditions under which data was generated from file
    f,N,e_min,e_max,e_num,a_min,a_max,a_num = settings
    e_num = int(e_num); a_num = int(a_num); N = int(N)

    # plot heatmap
    fig, ax = plt.subplots()
    im = ax.imshow(mat[mode],vmax=None)

    # configure and add x and y ticks
    nticksx = min(nticksx,e_num)
    nticksy = min(nticksy,a_num)
    ticksx = np.linspace(0,e_num-1,nticksx)
    ticksy = np.linspace(0,a_num-1,nticksy)
    tlabelsx = np.linspace(e_min,e_max,nticksx)
    tlabelsy = np.linspace(a_min,a_max,nticksy)

    ax.set_xticks(ticksx)
    ax.set_yticks(ticksy)
    ax.set_xticklabels(["{:.2f}".format(label) for label in tlabelsx])
    ax.set_yticklabels(["{:.2f}".format(label) for label in tlabelsy])

    ax.set_xlabel('e_dd')
    ax.set_ylabel('omega_z/omega_r')

    # strech pixels to output a square
    ax.set_aspect(e_num/a_num)

    fig.colorbar(im)

    # title graph with quantity corresponding to selected mode and conditions used for data
    if energies:
        label = energy_labels[mode]
    else:
        label = label_key[mode]
    fig.suptitle(f'{label}',fontsize='large')
    ax.set_title(f'gridsize: ({int(e_num)}x{int(a_num)}), f = {f} Hz, {N} atoms',fontsize='medium')
    
    plt.show()

def ani_generator(mat:np.ndarray,settings:np.ndarray,slice_index:int,save=False,fps = 20)->None:
    '''Produces an animation of the evolution of the longitudinal wavefunction across e_dd
    along a slice of constant trap aspect ratio by repeatedly calling animate. Can save as a gif.
    Inputs:
    - mat: output matrix in the format generated in gen_data_2d (data_generator.py)
    - settings: configuration file as generated by gen_data_2d
    - slice_index: index corresponding to aspect ratio value to use
    - save: if True, will save the resulting animation as a gif in the output directory
    - fps: frames per second in animation'''

    import matplotlib.animation
    frame_len = 1/fps

    # read conditions under which data was generated from file
    f,N,e_min,e_max,e_num,a_min,a_max,a_num = settings
    e_num = int(e_num); a_num = int(a_num); N = int(N)
    e_vals = np.linspace(e_min,e_max,e_num,endpoint=True)

    # read number of particles for each frame
    ns = mat[3,slice_index,:]

    # read longitudinal wavefunction parameters for each frame
    params = mat[6:,slice_index,:]

    # set integration length based on widest droplet configuration (lowest e_dd)
    L_set = 6*params[0,0]
    step = L_set/setup.RES
    n_widest = ns[0]
    if n_widest%2 == 0: # even droplets
       L_set += (n_widest-1)*params[1][0]
    elif n_widest>1: # odd droplets
        L_set += n_widest*params[1][0]
    zs = np.linspace(-L_set/2,L_set/2,setup.RES,endpoint=False)

    fig, ax = plt.subplots()
    fig.suptitle(f'Wavefunction evolution with e_dd\nf = {f} Hz, {N} atoms, \
        aspect ratio = {np.linspace(a_min,a_max,a_num,endpoint=True)[slice_index]:.3f}')

    # animate by repeatedly calling animate function
    ani = matplotlib.animation.FuncAnimation(fig, animate, range(len(e_vals)),
        interval=1000*frame_len,fargs=(ax,ns,params,zs,step,e_vals))

    # save animation using pillow writer
    if save:
        ani.save('outputs\\psi_evolution.gif','pillow')

    plt.show()

def animate(i:int,ax,ns:np.ndarray,params:np.ndarray,zs:np.ndarray,step:float,e_vals:np.ndarray)->None:
    '''Plots a single frame of the animation (only to be used within ani_generator)
    Inputs:
    - i: index of frame being called by the ani_generator function
    - ax: matplotlib axes object on which to call plot method
    - ns: array of numbers of droplets along e_dd
    - params: 2D array of longitudinal wavefunciton parameters, starting from index 6 in label_key.#
        params[j][i] is jth parameter for ith value of e_dd.
    - zs: array of z values over which to plot wavefunction
    - step: difference between two points in z
    - e_vals: array of values of e_dd
    - '''

    ax.clear()
    ax.grid()

    # show current value of e_dd in each frame
    ax.text(0.05,0.8,'e_dd = '+"{:.3f}".format(e_vals[i]),
        fontsize = 'large',transform=ax.transAxes)

    # get functional form corresponding to specified number of droplets
    n = int(ns[i])
    psi = setup.funcs[n-1]

    # gets number of parameters needed for funciton and extracts those form params array
    n_params = psi.__code__.co_argcount-1
    params = params[:n_params,i]
    
    # calculate and normalise values of psi_z
    psisq = psi(zs,*params)**2
    psisq = psisq / (step*np.sum(psisq))

    ax.plot(zs,psisq)

label_key = {
    0: 'Wavefunction contrast',
    1: 'Energy / hf',
    2: 'log10(decay time / s)',
    3: 'Droplet number',
    4: 'Transverse obliquity',
    5: 'Transverse length / QHO length',
    6: 'Droplet width / QHO length',
    7: 'Droplet separation / QHO length',
    8: '1st order relative height',
    9: '2nd order relative height'
}

energy_labels = {
    0: 'Interaction energy (d-d and contact) / hf',
    1: 'Quantum fluctuation energy / hf',
    2: 'Transverse kinetic energy / hf',
    3: 'Transverse potential energy / hf',
    4: 'Longitudinal kinetic energy / hf',
    5: 'Transverse kinetic energy / hf'
}

if __name__ == '__main__':
    mat = np.load('output\\outMat.npy')
    energies = np.load('output\\outEnergies.npy')
    settings = np.load('output\\settings.npy')
    plot_2d(mat,settings,0,False)